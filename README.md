# üìö Estructuras de Datos - Gu√≠a Completa

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![C++](https://img.shields.io/badge/C++-00599C?logo=c%2B%2B&logoColor=white)](https://isocpp.org/)
[![Java](https://img.shields.io/badge/Java-ED8B00?logo=java&logoColor=white)](https://www.java.com/)
[![Python](https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=white)](https://www.python.org/)

> **Curso completo de estructuras de datos con implementaciones en C++, Java y Python**. Esta gu√≠a proporciona explicaciones te√≥ricas detalladas, ejemplos pr√°cticos paso a paso y c√≥digo totalmente documentado para reforzar tu comprensi√≥n de las estructuras de datos fundamentales en programaci√≥n.

---

## üìë Tabla de Contenidos

- [Introducci√≥n](#-introducci√≥n)
- [Estructuras de Datos Lineales](#-estructuras-de-datos-lineales)
  - [Listas](#1-listas)
  - [Pilas](#2-pilas-stacks)
  - [Colas](#3-colas-queues)
- [Estructuras de Datos No Lineales](#-estructuras-de-datos-no-lineales)
  - [√Årboles](#1-√°rboles-trees)
  - [Grafos](#2-grafos-graphs)
- [Conceptos Avanzados](#-conceptos-avanzados)
- [C√≥mo Usar Este Repositorio](#-c√≥mo-usar-este-repositorio)
- [Recursos Externos](#-recursos-externos)

---

## üéØ Introducci√≥n

Las **estructuras de datos** son fundamentales en la programaci√≥n, ya que nos permiten organizar, gestionar y manipular informaci√≥n de manera eficiente. Una buena elecci√≥n de estructura de datos puede ser la diferencia entre un programa lento y uno extremadamente r√°pido.

Este repositorio est√° dise√±ado para estudiantes y desarrolladores que buscan:

- ‚úÖ Comprender a fondo c√≥mo funcionan las estructuras de datos
- ‚úÖ Ver implementaciones reales en m√∫ltiples lenguajes
- ‚úÖ Aprender con ejemplos visuales y explicaciones paso a paso
- ‚úÖ Prepararse para entrevistas t√©cnicas y ex√°menes

### Clasificaci√≥n General

```
Estructuras de Datos
‚îú‚îÄ‚îÄ Lineales
‚îÇ   ‚îú‚îÄ‚îÄ Listas (Est√°ticas, Enlazadas, Dobles, Circulares)
‚îÇ   ‚îú‚îÄ‚îÄ Pilas (LIFO)
‚îÇ   ‚îî‚îÄ‚îÄ Colas (FIFO)
‚îî‚îÄ‚îÄ No Lineales
    ‚îú‚îÄ‚îÄ √Årboles (Binarios, ABB)
    ‚îî‚îÄ‚îÄ Grafos (Dirigidos, No Dirigidos, Ponderados)
```

---

## üìä Estructuras de Datos Lineales

Las estructuras lineales organizan los elementos en una secuencia donde cada elemento (excepto el primero y el √∫ltimo) tiene un predecesor y un sucesor.

### 1. Listas

Las listas son colecciones ordenadas de elementos que permiten **inserci√≥n**, **eliminaci√≥n** y **b√∫squeda** eficientes seg√∫n su implementaci√≥n.

#### üìã Documentaci√≥n Te√≥rica

- **[Listas.md](Listas.md)** - Gu√≠a t√©cnica completa con diagramas ASCII, complejidades y comparativas

#### üîπ 1.1 Listas Est√°ticas (Arreglos)

**Caracter√≠sticas:**

- Tama√±o fijo definido en tiempo de compilaci√≥n
- Acceso directo en O(1) mediante √≠ndices
- Memoria contigua
- Inserci√≥n/eliminaci√≥n costosa O(n)

**Implementaciones:**

- [`lista_estatica/lista.cpp`](lista_estatica/lista.cpp) - Arreglo b√°sico en C++
- [`lista_estatica/lista.java`](lista_estatica/lista.java) - Array en Java con explicaci√≥n de archivadores
- [`lista_estatica/lista.py`](lista_estatica/lista.py) - Listas din√°micas de Python

**Aplicaciones:** Tablas de b√∫squeda, vectores matem√°ticos, buffers de tama√±o conocido

---

#### üîπ 1.2 Listas Enlazadas Simples

**Caracter√≠sticas:**

- Tama√±o din√°mico
- Cada nodo contiene dato + puntero al siguiente
- Recorrido unidireccional
- Inserci√≥n/eliminaci√≥n eficiente O(1) con referencia al nodo

**Implementaciones:**

- [`lista_enlazada/lista.cpp`](lista_enlazada/lista.cpp) - Implementaci√≥n con punteros en C++
- [`lista_enlazada/lista.java`](lista_enlazada/lista.java) - Implementaci√≥n detallada con analog√≠a de tren
- [`lista_enlazada/lista.py`](lista_enlazada/lista.py) - Versi√≥n Python con comentarios paso a paso

**Operaciones clave:**

- `insertarAlInicio(dato)` - Agrega nodo al frente
- `insertarAlFinal(dato)` - Agrega nodo al final
- `insertarDespuesDeCualquierNodoQueSeaMayorQue(dato, condicion)` - Inserci√≥n condicional
- `mostrarLista()` - Recorrido y visualizaci√≥n

**Aplicaciones:** Implementaci√≥n de pilas, colas, manejo de memoria din√°mica

---

#### üîπ 1.3 Listas Doblemente Enlazadas

**Caracter√≠sticas:**

- Cada nodo tiene puntero al siguiente Y al anterior
- Navegaci√≥n bidireccional
- Mayor consumo de memoria (2 punteros por nodo)
- Eliminaci√≥n m√°s eficiente (acceso directo a vecinos)

**Implementaciones:**

- [`lista_doblemente_enlazada/lista.cpp`](lista_doblemente_enlazada/lista.cpp) - Implementaci√≥n en C++ con punteros dobles
- [`lista_doblemente_enlazada/lista.java`](lista_doblemente_enlazada/lista.java) - Versi√≥n Java con `insertarEntre()`
- [`lista_doblemente_enlazada/lista.py`](lista_doblemente_enlazada/lista.py) - Python con navegaci√≥n bidireccional

**Operaciones especiales:**

- `mostrarListaAdelante()` - Recorrido de cabeza a cola
- `mostrarListaAtras()` - Recorrido de cola a cabeza
- `insertarEntre(dato, anterior, siguiente)` - Inserci√≥n entre nodos espec√≠ficos

**Aplicaciones:** Sistemas de deshacer/rehacer (undo/redo), historial de navegaci√≥n, editores de texto

---

#### üîπ 1.4 Listas Circulares

**Caracter√≠sticas:**

- El √∫ltimo nodo apunta al primero (formando un ciclo)
- No existe concepto de "final" (NULL)
- Recorrido infinito posible
- √ötil para algoritmos round-robin

**Implementaciones:**

- [`lista_circular/lista.cpp`](lista_circular/lista.cpp) - Lista circular simple en C++
- [`lista_circular/lista.java`](lista_circular/lista.java) - Implementaci√≥n con manejo de `ultimo`
- [`lista_circular/lista.py`](lista_circular/lista.py) - Versi√≥n Python circular

**Aplicaciones:** Planificadores de procesos (Round Robin), buffers circulares, carruseles de im√°genes

---

### 2. Pilas (Stacks)

Las pilas siguen el principio **LIFO** (Last In, First Out) - el √∫ltimo elemento en entrar es el primero en salir.

#### üìã Documentaci√≥n Te√≥rica

- **[pilas/README.md](pilas/README.md)** - Gu√≠a exhaustiva con diagramas detallados de operaciones, casos de uso y ejercicios resueltos

#### üéØ Operaciones Fundamentales

- `push(elemento)` - Insertar en el tope (O(1))
- `pop()` - Extraer del tope (O(1))
- `peek()` - Ver el tope sin extraer (O(1))
- `isEmpty()` - Verificar si est√° vac√≠a (O(1))

#### üíª Implementaciones B√°sicas

- [`pilas/pila.cpp`](pilas/pila.cpp) - Implementaci√≥n con nodos enlazados
- [`pilas/pila.java`](pilas/pila.java) - Versi√≥n Java con m√©todo `mergePilas()`
- [`pilas/pila.py`](pilas/pila.py) - Implementaci√≥n Python minimalista

#### üßÆ Aplicaciones Avanzadas

**Balanceo de Par√©ntesis:**

- [`pilas/pilaCaracter.cpp`](pilas/pilaCaracter.cpp)
- [`pilas/pilaCaracter.java`](pilas/pilaCaracter.java)
- [`pilas/pilaCaracter.py`](pilas/pilaCaracter.py)

Verifican si s√≠mbolos `()`, `[]`, `{}` est√°n correctamente emparejados usando pilas. Esencial para compiladores y parsers.

**Transformaci√≥n de Notaciones (Algoritmo Shunting Yard):**

- [`pilas/infijoTransformador.cpp`](pilas/infijoTransformador.cpp)
- [`pilas/infijoTransformacion.java`](pilas/infijoTransformacion.java)
- [`pilas/infijoTransformador.py`](pilas/infijoTransformador.py)

Convierte expresiones **infijas** (`A + B * C`) a **postfijas** (`A B C * +`) y **prefijas** (`+ A * B C`), respetando precedencia de operadores.

**Casos de uso reales:**

- Call Stack (gesti√≥n de llamadas a funciones)
- Historial de navegaci√≥n (bot√≥n "Atr√°s")
- Evaluaci√≥n de expresiones matem√°ticas
- Algoritmos de backtracking

---

### 3. Colas (Queues)

Las colas siguen el principio **FIFO** (First In, First Out) - el primero en entrar es el primero en salir.

#### üìã Documentaci√≥n Te√≥rica

- **[colas/README.md](colas/README.md)** - Explicaci√≥n detallada con diagramas, ejercicios complementarios y analog√≠as visuales

#### üéØ Operaciones Fundamentales

- `enqueue(elemento)` - Insertar al final (O(1))
- `dequeue()` - Extraer del frente (O(1))
- `peek()` - Ver el frente sin extraer (O(1))
- `isEmpty()` - Verificar si est√° vac√≠a (O(1))

#### üíª Implementaciones

**Colas B√°sicas (sin l√≠mite):**

- [`colas/cola.cpp`](colas/cola.cpp) - Implementaci√≥n con struct y punteros
- [`colas/cola.java`](colas/cola.java) - Versi√≥n Java orientada a objetos
- [`colas/cola.py`](colas/cola.py) - Python con clase Cola

**Colas con L√≠mite (capacity):**

- [`colas/colaConLimite.cpp`](colas/colaConLimite.cpp) - Control de capacidad m√°xima
- [`colas/colaConLimite.java`](colas/colaConLimite.java) - Java con validaci√≥n de l√≠mites
- [`colas/colaConLimite.py`](colas/colaConLimite.py) - Python con restricci√≥n de tama√±o

#### üß© Operaciones Avanzadas

Las implementaciones incluyen:

- `invertir()` - Inversi√≥n recursiva de la cola
- `mostrar()` - Visualizaci√≥n sin modificar estructura
- `unirYOrdenarDosColas()` - Fusi√≥n y ordenamiento (Bubble Sort)
- `bubbleSortOrdenar()` - Ordenamiento in-place

**Casos de uso reales:**

- Colas de impresi√≥n
- Gesti√≥n de tareas en background
- Buffer de teclado
- Algoritmos BFS (Breadth-First Search)
- Sistemas de atenci√≥n al cliente

---

## üå≥ Estructuras de Datos No Lineales

En las estructuras no lineales, los elementos no siguen una secuencia √∫nica sino que pueden tener m√∫ltiples conexiones, formando jerarqu√≠as o redes.

### 1. √Årboles (Trees)

Los √°rboles son estructuras jer√°rquicas donde cada nodo tiene un padre (excepto la ra√≠z) y cero o m√°s hijos.

#### üìã Documentaci√≥n Te√≥rica

- **[ArbolesLimites.md](ArbolesLimites.md)** - Explicaci√≥n crucial sobre por qu√© son necesarios los l√≠mites [min, max] en la validaci√≥n de ABB

#### üéØ √Årbol Binario de B√∫squeda (ABB)

**Propiedades:**

- Cada nodo tiene m√°ximo 2 hijos (izquierdo y derecho)
- **Sub√°rbol izquierdo:** todos los valores < ra√≠z
- **Sub√°rbol derecho:** todos los valores > ra√≠z
- B√∫squeda, inserci√≥n y eliminaci√≥n en O(log n) promedio

#### üíª Implementaciones Recursivas

**Versiones Completas:**

- [`arboles/Arbol.cpp`](arboles/Arbol.cpp) - Implementaci√≥n procedural recursiva en C++
- [`arboles/Arbol.java`](arboles/Arbol.java) - Versi√≥n orientada a objetos en Java
- [`arboles/Arbol.py`](arboles/Arbol.py) - Implementaci√≥n recursiva en Python

**Operaciones implementadas:**

- `insertar(valor)` - Inserci√≥n recursiva manteniendo propiedad ABB
- `eliminar(valor)` - Eliminaci√≥n con 3 casos (hoja, 1 hijo, 2 hijos)
- `encontrarMinimo(nodo)` - Encuentra el sucesor inorden
- Recorridos:
  - `inOrden()` - Izquierda ‚Üí Ra√≠z ‚Üí Derecha (orden ascendente)
  - `preOrden()` - Ra√≠z ‚Üí Izquierda ‚Üí Derecha
  - `postOrden()` - Izquierda ‚Üí Derecha ‚Üí Ra√≠z
- `calcularAltura()` - Altura del √°rbol (camino m√°s largo)
- `esArbolValido()` - Validaci√≥n con l√≠mites [min, max] propagados

#### üíª Implementaciones Iterativas

- [`arboles/ArbolBinarioBusquedaIterativo.cpp`](arboles/ArbolBinarioBusquedaIterativo.cpp) - Versi√≥n iterativa con algoritmo Morris
- [`arboles/ArbolBinarioBusquedaIterativo.java`](arboles/ArbolBinarioBusquedaIterativo.java) - Java iterativo con Morris
- [`arboles/ArbolBinarioBusquedaIterativo.py`](arboles/ArbolBinarioBusquedaIterativo.py) - Python iterativo con Morris

**Caracter√≠sticas especiales:**

- Implementa **Algoritmo de Morris** para recorridos sin pila ni recursi√≥n (O(1) memoria)
- Evita riesgo de Stack Overflow en √°rboles profundos
- M√°s eficiente en memoria para ciertos casos
- Mejor control del flujo de ejecuci√≥n

**Casos de uso reales:**

- Bases de datos (√≠ndices B-Tree)
- Sistemas de archivos
- Autocompletado y diccionarios
- Compiladores (√°rboles de sintaxis)

---

### 2. Grafos (Graphs)

Los grafos modelan relaciones entre entidades mediante **v√©rtices** (nodos) y **aristas** (conexiones).

#### üìã Documentaci√≥n Te√≥rica Completa

- **[Grafos.md](Grafos.md)** - Gu√≠a exhaustiva con definiciones, tipos, algoritmos y diagramas visuales
- **[GrafosAlgoritmos.md](GrafosAlgoritmos.md)** - Simulaciones paso a paso de BFS, DFS, detecci√≥n de ciclos, etc.
- **[FloydWarshall.md](FloydWarshall.md)** - Algoritmos de caminos m√≠nimos (Floyd-Warshall y Warshall)

#### üî∑ Tipos de Grafos Implementados

**1. Grafo Simple (No Dirigido):**

- [`grafos/GrafoSimple.cpp`](grafos/GrafoSimple.cpp)
- [`grafos/GrafoSimple.java`](grafos/GrafoSimple.java)
- [`grafos/GrafoSimple.py`](grafos/GrafoSimple.py)
- [`grafos/GrafoSimpleConColoresSoloDidactico.java`](grafos/GrafoSimpleConColoresSoloDidactico.java) - Versi√≥n educativa con colores

**Caracter√≠sticas:** Aristas bidireccionales, representan relaciones sim√©tricas (amistades, carreteras de doble sentido).

**2. Grafo Dirigido (D√≠grafo):**

- [`grafos/GrafoDirigido.cpp`](grafos/GrafoDirigido.cpp)
- [`grafos/GrafoDirigido.java`](grafos/GrafoDirigido.java)
- [`grafos/GrafoDirigido.py`](grafos/GrafoDirigido.py)

**Caracter√≠sticas:** Aristas con direcci√≥n (A‚ÜíB ‚â† B‚ÜíA), modelan relaciones asim√©tricas (seguir en Twitter, dependencias de tareas).

**3. Grafo Ponderado:**

- [`grafos/GrafoPonderado.cpp`](grafos/GrafoPonderado.cpp)
- [`grafos/GrafoPonderado.java`](grafos/GrafoPonderado.java)
- [`grafos/GrafoPonderado.py`](grafos/GrafoPonderado.py)

**Caracter√≠sticas:** Cada arista tiene un peso/costo, usado en problemas de optimizaci√≥n (GPS, log√≠stica).

**4. Grafo Conectado:**

- [`grafos/GrafoConectado.cpp`](grafos/GrafoConectado.cpp)
- [`grafos/GrafoConectado.java`](grafos/GrafoConectado.java)
- [`grafos/GrafoConectado.py`](grafos/GrafoConectado.py)

**Caracter√≠sticas:** Existe camino entre cualquier par de v√©rtices, no hay "islas" aisladas.

#### üéØ Algoritmos Implementados

**Recorridos:**

- **BFS** (B√∫squeda en Anchura) - O(V + E) - Explora por niveles, encuentra camino m√°s corto en grafos no ponderados
- **DFS** (B√∫squeda en Profundidad) - O(V + E) - Explora a fondo antes de retroceder, detecta ciclos

**An√°lisis de Propiedades:**

- `tieneCiclo()` - Detecci√≥n de ciclos usando DFS
- `contarComponentesConectadas()` - Cuenta "islas" del grafo
- `distanciaMasCorta(inicio, fin)` - BFS con conteo de distancias
- `gradoVertice(v)` - N√∫mero de conexiones de un v√©rtice
- `esBipartito()` - Verificaci√≥n con coloraci√≥n (2 colores)
- `esArbol()` - Verifica si es conexo y ac√≠clico

**Algoritmos de Caminos:**

- **Floyd-Warshall** - Caminos m√≠nimos entre todos los pares de v√©rtices - [`grafos/GrafoDirigidoFloydWarshall.java`](grafos/GrafoDirigidoFloydWarshall.java)
- **Warshall** - Cierre transitivo (existencia de caminos)

#### üìä Representaciones

- **Matriz de Adyacencia:** Tabla V√óV, r√°pida para verificar conexiones O(1), pero consume O(V¬≤) memoria
- **Lista de Adyacencia:** Cada v√©rtice tiene lista de vecinos, eficiente para grafos dispersos O(V + E)

**Casos de uso reales:**

- Redes sociales (amistades, seguidores)
- Sistemas GPS (rutas, mapas)
- Internet (p√°ginas web, enlaces)
- Redes neuronales
- An√°lisis de dependencias (compilaci√≥n, gesti√≥n de proyectos)

---

## üöÄ Conceptos Avanzados

### Recursividad

#### üìã Documentaci√≥n

- **[Recursividad.md](Recursividad.md)** - Gu√≠a completa con analog√≠as de Inception, visualizaci√≥n de pila de llamadas

**Conceptos clave:**

- **Caso base:** Condici√≥n de parada
- **Paso recursivo:** Llamada con problema m√°s peque√±o
- Visualizaci√≥n con `factorial(3)` paso a paso
- Comparativa recursividad vs iteraci√≥n

**Ejemplos en el repositorio:**

- Fibonacci y Tribonacci: [`capacho/tri_fi_bonacci/`](capacho/tri_fi_bonacci/)
  - Python: [`Fibonnaci.py`](capacho/tri_fi_bonacci/Fibonnaci.py), [`Tribonnaci.py`](capacho/tri_fi_bonacci/Tribonnaci.py)
  - Java: [`Fibonacci.java`](capacho/tri_fi_bonacci/Fibonacci.java), [`Tribonacci.java`](capacho/tri_fi_bonacci/Tribonacci.java)
  - Notebooks: [`Fibonnaci.ipynb`](capacho/tri_fi_bonacci/Fibonnaci.ipynb), [`Tribonnaci.ipynb`](capacho/tri_fi_bonacci/Tribonnaci.ipynb)
- Lista doblemente enlazada recursiva: [`recursividad/lista_doblemente_enlazada.java`](recursividad/lista_doblemente_enlazada.java)

---

## üí° C√≥mo Usar Este Repositorio

### Para Estudiantes

1. **Lee la documentaci√≥n te√≥rica** (archivos `.md`) primero para entender los conceptos
2. **Estudia las implementaciones** en tu lenguaje preferido
3. **Ejecuta el c√≥digo** y observa los resultados
4. **Modifica los ejemplos** para experimentar
5. **Consulta las gu√≠as visuales** cuando tengas dudas

### Estructura de Archivos

```
curso-estructura-de-datos/
‚îú‚îÄ‚îÄ README.md                          ‚Üê Est√°s aqu√≠
‚îú‚îÄ‚îÄ Listas.md                          ‚Üê Teor√≠a de listas
‚îú‚îÄ‚îÄ Recursividad.md                    ‚Üê Teor√≠a de recursividad
‚îú‚îÄ‚îÄ Grafos.md                          ‚Üê Teor√≠a de grafos
‚îú‚îÄ‚îÄ GrafosAlgoritmos.md               ‚Üê Simulaciones de algoritmos
‚îú‚îÄ‚îÄ ArbolesLimites.md                 ‚Üê Validaci√≥n de ABB
‚îú‚îÄ‚îÄ FloydWarshall.md                  ‚Üê Algoritmos de caminos
‚îÇ
‚îú‚îÄ‚îÄ lista_estatica/                    ‚Üê Arreglos
‚îÇ   ‚îú‚îÄ‚îÄ lista.cpp
‚îÇ   ‚îú‚îÄ‚îÄ lista.java
‚îÇ   ‚îî‚îÄ‚îÄ lista.py
‚îÇ
‚îú‚îÄ‚îÄ lista_enlazada/                    ‚Üê Listas simples
‚îÇ   ‚îú‚îÄ‚îÄ lista.cpp
‚îÇ   ‚îú‚îÄ‚îÄ lista.java
‚îÇ   ‚îî‚îÄ‚îÄ lista.py
‚îÇ
‚îú‚îÄ‚îÄ lista_doblemente_enlazada/         ‚Üê Listas dobles
‚îÇ   ‚îú‚îÄ‚îÄ lista.cpp
‚îÇ   ‚îú‚îÄ‚îÄ lista.java
‚îÇ   ‚îî‚îÄ‚îÄ lista.py
‚îÇ
‚îú‚îÄ‚îÄ lista_circular/                    ‚Üê Listas circulares
‚îÇ   ‚îú‚îÄ‚îÄ lista.cpp
‚îÇ   ‚îú‚îÄ‚îÄ lista.java
‚îÇ   ‚îî‚îÄ‚îÄ lista.py
‚îÇ
‚îú‚îÄ‚îÄ pilas/                             ‚Üê Pilas (LIFO)
‚îÇ   ‚îú‚îÄ‚îÄ README.md                      ‚Üê Gu√≠a detallada
‚îÇ   ‚îú‚îÄ‚îÄ pila.cpp
‚îÇ   ‚îú‚îÄ‚îÄ pila.java
‚îÇ   ‚îú‚îÄ‚îÄ pila.py
‚îÇ   ‚îú‚îÄ‚îÄ pilaCaracter.*                 ‚Üê Balanceo de par√©ntesis
‚îÇ   ‚îî‚îÄ‚îÄ infijoTransformador.*          ‚Üê Conversi√≥n de notaciones
‚îÇ
‚îú‚îÄ‚îÄ colas/                             ‚Üê Colas (FIFO)
‚îÇ   ‚îú‚îÄ‚îÄ README.md                      ‚Üê Gu√≠a detallada
‚îÇ   ‚îú‚îÄ‚îÄ cola.cpp
‚îÇ   ‚îú‚îÄ‚îÄ cola.java
‚îÇ   ‚îú‚îÄ‚îÄ cola.py
‚îÇ   ‚îú‚îÄ‚îÄ colaConLimite.*                ‚Üê Colas con capacidad
‚îÇ
‚îú‚îÄ‚îÄ arboles/                           ‚Üê √Årboles binarios
‚îÇ   ‚îú‚îÄ‚îÄ Arbol.cpp                      ‚Üê ABB recursivo C++
‚îÇ   ‚îú‚îÄ‚îÄ Arbol.java                     ‚Üê ABB recursivo Java
‚îÇ   ‚îú‚îÄ‚îÄ Arbol.py                       ‚Üê ABB recursivo Python
‚îÇ   ‚îú‚îÄ‚îÄ ArbolBinarioBusquedaIterativo.cpp  ‚Üê ABB iterativo C++
‚îÇ   ‚îú‚îÄ‚îÄ ArbolBinarioBusquedaIterativo.java ‚Üê ABB iterativo Java
‚îÇ   ‚îî‚îÄ‚îÄ ArbolBinarioBusquedaIterativo.py   ‚Üê ABB iterativo Python
‚îÇ
‚îî‚îÄ‚îÄ grafos/                            ‚Üê Grafos
    ‚îú‚îÄ‚îÄ GrafoSimple.*                  ‚Üê No dirigido
    ‚îú‚îÄ‚îÄ GrafoDirigido.*                ‚Üê Dirigido
    ‚îú‚îÄ‚îÄ GrafoPonderado.*               ‚Üê Con pesos
    ‚îú‚îÄ‚îÄ GrafoConectado.*               ‚Üê Conexo
    ‚îú‚îÄ‚îÄ GrafoDirigidoFloydWarshall.java
    ‚îî‚îÄ‚îÄ GrafoSimpleConColoresSoloDidactico.java
```

### Compilaci√≥n y Ejecuci√≥n

**C++:**

```bash
g++ -o programa archivo.cpp
./programa
```

**Java:**

```bash
javac archivo.java
java NombreClase
```

**Python:**

```bash
python archivo.py
# o
python3 archivo.py
```

---

## üìö Recursos Externos

### Documentaci√≥n Oficial

- [C++ Reference](https://en.cppreference.com/)
- [Java Documentation](https://docs.oracle.com/en/java/)
- [Python Documentation](https://docs.python.org/3/)

### Tutoriales y Gu√≠as

- [GeeksforGeeks - Data Structures](https://www.geeksforgeeks.org/data-structures/)
- [Visualgo - Visualizaci√≥n de Algoritmos](https://visualgo.net/)
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)

### Lecturas Recomendadas

- [Techie Delight - Static Linked List in C](https://www.techiedelight.com/static-linked-list-c/)
- [Universidad de Cantabria - Listas y Colas](https://personales.unican.es/corcuerp/progcomp/slides/Listas_Colas.pdf)
- [GeeksforGeeks - Linked List](https://www.geeksforgeeks.org/data-structures/linked-list/)
- [W3Schools - C++ Data Structures](https://www.w3schools.com/cpp/cpp_data_structures.asp)

---

## ü§ù Contribuciones

Este repositorio es de c√≥digo abierto y acepta contribuciones. Si encuentras errores o quieres agregar implementaciones:

1. Fork el repositorio
2. Crea una rama para tu feature
3. Haz commit de tus cambios
4. Env√≠a un Pull Request

---

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT. Si√©ntete libre de usar, modificar y distribuir el c√≥digo con fines educativos.

---

**¬øPreguntas o sugerencias?** Abre un issue en el repositorio.

**‚≠ê Si este repositorio te ha sido √∫til, considera darle una estrella en GitHub.**
